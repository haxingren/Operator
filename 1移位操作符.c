#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main()
{
	//
	//移动操作符只能对整型使用
	//
	//移动操作符，移动的是二进制位

	//整数的二进制表示有三种
	//1原码
	//2反码
	//3补码

	//正整数的原码，反码，补码相同
	//负整数的原码，反码，补码需要计算


	//<< 左移操作符
	//例子
	//十进制：7
	//二进制：111
	//整型存在编译器里要占4个字节，即32个bit:00000000000000000000000000000111
	// 
	// 00000000000000000000000000000111 —— 原码/反码/补码（因为这是正数）所以三者相同
	// 第一个数字为他的最高位，最高位=0表示他是正数，最高位=1时表示他是负数


	//十进制：-7
	//10000000000000000000000000000111 —— 原码
	//11111111111111111111111111111000 —— 反码（符号位不变，其他1和0置换）
	//11111111111111111111111111111001 —— 补码（补码就是反码+1）

	//整数在内存中存放的是补码
	//所以移动操作符是对补码进行移动

	int a = 7;
	int b = a << 1;
	//7的补码：00000000000000000000000000000111
	//左移后 ：00000000000000000000000000001110 —— 换算后得14
	//左移后，左边丢弃一位，右边补零
	printf("%d\n", a);
	printf("%d\n", b);

	//如果是负数
	int c = -7;
	int d = c << 1;
	//-7的原码：10000000000000000000000000000111
	//	  反码：11111111111111111111111111111000
	//	  补码：11111111111111111111111111111001
	// 左移补码：
	//左移后 补码：11111111111111111111111111110010
	//然后要输出为10进制前要换算会原码
	//反码 (补码-1)：11111111111111111111111111110001
	//原码		  ：10000000000000000000000000001110
	printf("%d\n", c);
	printf("%d\n", d);

	//
	//最后发现二进制每左移一位就等于十进制乘二
	//



	//
	//>> 右移操作符
	// 
	//例子
	int e = 7;
	int f = a >> 1;
	//7的补码：00000000000000000000000000000111
	//右移后 ：00000000000000000000000000000011 —— 
	// 算术移位：右边丢弃，左边补原符号位
	// 逻辑移位：右边丢弃，左边补零
	//对于正数来说，不过是算术还是逻辑移位，其结果都会是补零
	printf("%d\n", e);
	printf("%d\n", f);

	//但是在负数位移时
	int g = -7;
	int h = g >> 1;
	//-7的原码：10000000000000000000000000000111
	//	  反码：11111111111111111111111111111000
	//	  补码：11111111111111111111111111111001
	//右移后，如果是算术移位， 补码： 1111111111111111111111111111100
	//						 反码：1111111111111111111111111111011
	//                       原码：1000000000000000000000000000100（得-4）
	printf("%d\n", g);
	printf("%d\n", h);

	//究竟使用算术移位还是逻辑移位取决于编译器
	//不过大部分编译器都使用算术移位

	//移位操作符的移位数只能是正整数，-1或者0.1都是不允许的
	int i = g >> 1;
	return 0;
}