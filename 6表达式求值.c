#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

//表达式求职的顺序
//由操作符的优先级和结合性决定
//有些表达式的操作数在求值的过程中可能需要转换为其他类型


//	//
//	//1隐式类型转换
//	// 
//int main()
//{
//	//C的整型算术运算总是至少以缺省整型类型的精度来进行的（最小的运算精度为int）
//	//为了获得这个精度，表达式中的字符（char）和短整型（short）操作数在使用之前被转换为普通整型（int），这种转换称为整型提升
//
//	//整型提升有什么意义吗
//	//表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器（ALU）的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度
//	//由此两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度
//	//通用CPU(general-purpose CPU)是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。
//	//所以表达式中各种长度可能小于int长度的整型值，都必须先转换为int 或者 unsigned int，然后才能送入CPU去执行运算
//
//	//如何进行整型提升呢
//	//整型提升是按照变量的数据类型的符号位来提升的
//	char c = -1;//-1是整数，是32个bit位
//	//10000000000000000000000000000001 - -1的原码
//	//11111111111111111111111111111110 - -1的反码
//	//11111111111111111111111111111111 - -1的补码
//	//补码要存进变量c，但是c的类型是char，只有8个bit位的空间，所以只能截取8位
//	//11111111 - c的补码
//	//整型提升后（根据符号位来进行整型提升，符号位为1，就从高位补1，直到达到32个bit位
//	//11111111111111111111111111111111
//	
//
//	//例子证明整型提升的存在
//	char a = 5;
//	//00000000000000000000000000000101 - 5的原码（补码）
//	//000000101 - a的原码（补码）（
//	char b = 126;
//	//00000000000000000000000001111110 - 126的原码（补码）
//	//01111110 - b的原码（补码）
//	char d = a + b;
//	//相加时要结果整型提升，变回32位的二进制
//	//00000000000000000000000000000101 +
//	//00000000000000000000000001111110 =
//	//00000000000000000000000010000011
//	//计算后变回char的8位（截取最后8位号码）
//	//10000011 - d的补码
//	printf("%d\n", d);
//	//以整型的形式打印，至少需要int的精度，所以要整型提升，第一位是1，所以高位补1
//	//11111111111111111111111110000011 - 补码
//	//11111111111111111111111110000010 - 反码
//	//10000000000000000000000001111101 - 原码（得-125）
//
//
//	char x = 0xb6;
//	short y = 0xb600;
//	int z = 0xb000000;
//	if (x == 0xb6)
//		printf("x");
//	if (y == 0xb600)
//		printf("y");
//	if (z == 0xb000000)
//		printf("z\n");
//	//最终只打印了z，因为，只要表达式中出现了char或者short的操作数，就会发生整型提升，结果整型提升后他们自然跟原本的值不一样了，而int类型的操作数不需要整型提升
//	//如果用unsigned char/short，x和y就可以打印了，因为无符号整型在整型提升时是直接高位补0，补0后0xb6和000000000000000000xb6的值并没有什么差别 
//
//
//	char i = 1;
//	printf("%u\n", sizeof(i));//1
//	printf("%u\n", sizeof(+i));//4
//	printf("%u\n", sizeof(-i));//4
//	//为什么+i,-i的大小会是4呢
//	//虽然+i,-i这样的表达式并没有什么效果，但是也是表达式，进入表达式的操作数如果是char或者short类型的话就会整型提升为int
//	return 0;
//}


	//
	//算术转换
	//
	//如果某个操作符的各个操作数属于不同的类型，那么除非一个操作数的类型转换成另一个操作数的类型，否则操作就无法进行
	//以下的层次体系成为寻常算术转换
	// long double
	// double
	// float
	// unsigned long int
	// long int
	// unsigned int
	// int
	// 如果某个操作数的类型在这个列表上的排名较低，那么首先要转换为另一个操作数的类型才能执行运算


	//
	//操作符的属性
	//

	//复杂表达式的求值有三个影响的因素
	//1操作符的优先级
	//2操作符的结合性
	//3是否控制求值顺序
	
	//两个操作符相邻时，优先级较高的先执行，如果优先级一样，则取决于他们的结合性

	//操作符            描述                    用法示例              结果类型           结合性      是否控制求值顺序
	// ()              聚组		           	  (表达式)             与表达式同          N / A				 否
	// ()			 函数调用              rexp(rexp，...,rexp)        rexp             L-R                否
	// [ ]           下标引用                  rexp[rexp]              lexp             L-R                否
	//  .           访问结构成员            lexp.member_name           lexp             L - R               否
	//	->        访问结构指针成员            rexp->member_name         lexp             L - R              否
	//	++           后缀自增                    lexp ++               rexp             L - R               否
	//	--           后缀自减                   lexp --                 rexp             L - R             否
	//	!			 逻辑反					! rexp						rexp			R-L				 否
	//	~			按位取反					 ~rexp						rexp			R - L			 否
	//	+			 单目，表示正值			+ rexp						rexp			 R - L			 否
	//	-			单目，表示负值			- rexp					 rexp				 R - L				否
	//	++			 前缀自增				 ++ lexp					rexp			R - L				否
	//	--				前缀自减				 -- lexp					rexp			R - L				否
	//	*				间接访问					* rexp					lexp			R - L				否
	//	&				取地址				 & lexp						rexp			R - L				否
	//	sizeof	 取其长度，以字节表示   	sizeof rexp sizeof(类型)        rexp            R - L                否
	//	(类型）		类型转换(类型)				 rexp					 rexp			R - L				 否
	//	*				乘法					 rexp * rexp				 rexp			 L - R				 否
	//	/				除法					rexp / rexp					rexp			L - R				 否
	//	%				整数取余				rexp % rexp					 rexp			L - R				否
	//	+				加法					rexp + rexp					 rexp			 L - R				 否
	//	-				减法					 rexp - rexp				rexp			L - R				 否
	//	<<				左移位				rexp << rexp				rexp			L - R				否
	//	>>				 右移位				 rexp >> rexp				rexp			 L - R				 否
	//	>				大于					rexp > rexp					rexp			 L - R				否
	//	>=				大于等于				 rexp >= rexp				 rexp			L - R				 否
	//	<				小于					 rexp < rexp				 rexp			L - R				 否
	//	<=				小于等于					rexp <= rexp			rexp			 L - R				 否
	//  ==				等于					 rexp == rexp				rexp			L-R					否
	//  !=				不等于				rexp != rexp				 rexp			 L - R				否
	//	&				位与					rexp & rexp					 rexp			 L - R				否
	//	^				位异或				rexp ^ rexp					rexp			 L - R				否
	//	|				位或				rexp | rexp						rexp			L - R				 否
	//	&&				逻辑与			 rexp && rexp					 rexp			 L - R				是
	//	||				 逻辑或				rexp || rexp				 rexp			 L - R				 是
	//	? :				 条件操作符		 rexp ? rexp : rexp				rexp			 N / A				是
	//	=				赋值				lexp = rexp						 rexp			 R - L				否
	//	+=				以...加			 lexp += rexp					rexp			 R - L				否
	//	-=				以...减			lexp -= rexp					rexp			R - L				否
	//	*=				 以...乘				lexp *= rexp				 rexp			R - L				否
	//	/=				以...除			 lexp /= rexp					rexp			 R - L				 否
	//	%=				以...取模			 lexp %= rexp				 rexp			R - L				否
	//	<<=				 以...左移			 lexp <<= rexp				 rexp			R - L				否
	//	>>=				以...右移			 lexp >>= rexp				 rexp			R - L				否
	//	&=				以...与			 lexp &= rexp					 rexp			R - L				否
	//	^=				以...异或			lexp ^= rexp				 rexp			R - L				否
	//	|=				以...或				lexp |= rexp				rexp			 R - L				否
	//	，				逗号				 rexp，rexp						rexp			L - R				是


	//问题表达式
	//虽然根据操作符的优先级，操作符的结合性，是否控制求值顺序，这三种因素我们可以推断出表达式的推算路径
	//但是还是有些表达式是没有唯一的推算路径的，我们无从得知其具体到底是什么顺序
	//这些表达式叫做 问题表达式
	//比如a*b + c*d + e*f
	//我们知道肯定是先*后+，但是是a*b先呢，还是c*d先呢
	//如果a*b的结果会影响到c，那么当此运算的推算路径不确定时，我们也无法确定表达式的结果
	//这样就可能有一些潜在的问题
	//所以应该确保写出来的表达式有唯一的推算路径
